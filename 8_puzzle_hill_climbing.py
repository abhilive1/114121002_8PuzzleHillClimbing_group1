# -*- coding: utf-8 -*-
"""8_puzzle_hill_climbing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rlDJd_xA7oZdolW0VGdk91HzXm6lk3Fl
"""

import random

class Puzzles:
    def __init__(self, initial, goal):
        self.initial = initial
        self.goal = goal
        self.size = int(len(initial) ** 0.5)

    def find_blank(self, state):
        #Get the index of the blank tile (represented by 0).
        return state.index(0)

    def manhattan_distance(self, state):
        #Manhattan distance between current state and the goal.
        distance = 0
        for i, tile in enumerate(state):
            if tile != 0:  # Ignore the blank tile
                goal_index = self.goal.index(tile)
                distance += abs(i // self.size - goal_index // self.size) + abs(i % self.size - goal_index % self.size)
        return distance

    def get_neighbors(self, state):
        #Get all valid neighbors of the current puzzle state.
        blank = self.find_blank(state)
        neighbors = []
        moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for i in moves:
            x, y = divmod(blank, self.size)
            nx, ny = x + i[0], y + i[1]
            if 0 <= nx < self.size and 0 <= ny < self.size:
                neighbor = state[:]
                swap_idx = nx * self.size + ny
                neighbor[blank], neighbor[swap_idx] = neighbor[swap_idx], neighbor[blank]
                neighbors.append(neighbor)
        return neighbors

# Random Restart Hill Climbing Method

class PuzzleWithRestart(Puzzles):
    def random_state(self):
        #Generate a random puzzle state.
        state = self.goal[:]
        random.shuffle(state)
        return state

    def random_restart_hill_climbing(self, max_restarts=100):
        for restart in range(max_restarts):
            current = self.random_state()
            initial_state = current[:]  # Storing the initial random state
            while True:
                neighbors = self.get_neighbors(current)
                next_state = min(neighbors, key=lambda x: self.manhattan_distance(x))
                if self.manhattan_distance(next_state) >= self.manhattan_distance(current):
                    break
                current = next_state
            if self.manhattan_distance(current) == 0:
                return initial_state, current  # Return the initial and goal state when found
        return None, None  # Unable to find solution after max_restarts

# First Choice Hill Climbing Method

class PuzzleWithFirstChoice(Puzzles):
    def first_choice_hill_climbing(self, max_attempts=100):
        current = self.initial[:]
        initial_state = current[:]  # Storing the initial state
        attempts = 0
        while attempts < max_attempts:
            neighbors = self.get_neighbors(current)
            random.shuffle(neighbors)  # Shuffle the neighbors to make the search random
            for neighbor in neighbors:
                if self.manhattan_distance(neighbor) < self.manhattan_distance(current):
                    current = neighbor
                    attempts = 0  # Reset attempts as we made progress
                    break
            else:
                attempts += 1
        return initial_state, current if self.manhattan_distance(current) == 0 else None

initial_state = [2,8,3,1,6,4,7,0,5]
goal_state = [1,2,3,8,0,4,7,6,5]

# Call Random Restart Hill Climbing Method
puzzle_with_restart_algo = PuzzleWithRestart(initial_state, goal_state)
initial, final = puzzle_with_restart_algo.random_restart_hill_climbing(max_restarts=100)
print("Random Restart Hill Climbing Initial State:", initial)
print("Random Restart Hill Climbing Final State:", final)

#Call First Choice Hill Climbing Method
puzzle_with_first_choice_algo = PuzzleWithFirstChoice(initial_state, goal_state)
initial, final = puzzle_with_first_choice_algo.first_choice_hill_climbing(max_attempts=100)
print("First Choice Hill Climbing Initial State:", initial)
print("First Choice Hill Climbing Final State:", final)